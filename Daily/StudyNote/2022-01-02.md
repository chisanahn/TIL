# í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 1ì¼ 1ë¬¸ì œ

Lv.2 [ì¹´ì¹´ì˜¤í”„ë Œì¦ˆ ì»¬ëŸ¬ë§ë¶](https://programmers.co.kr/learn/courses/30/lessons/1829)

dfsë¡œ ê°„ë‹¨í•˜ê²Œ í’€ì—ˆë‹¤.

<details><summary>ì†ŒìŠ¤ì½”ë“œ</summary>

```
import static java.lang.Math.*;

public class Solution {
    public static int dfs(int[][] picture, int[][] visit, int i, int j) {
        if (visit[i][j] == 1) return 0;

        visit[i][j] = 1;
        int ret = 1;

        // ì™¼ìª½ ì²´í¬
        if (j - 1 >= 0 && picture[i][j] == picture[i][j - 1]) {
            ret += dfs(picture, visit, i, j - 1);
        }
        // ìœ„ìª½ ì²´í¬
        if (i - 1 >= 0 && picture[i][j] == picture[i - 1][j]) {
            ret += dfs(picture, visit, i - 1, j);
        }
        // ì˜¤ë¥¸ìª½ ì²´í¬
        if (j + 1 < picture[0].length && picture[i][j] == picture[i][j + 1]) {
            ret += dfs(picture, visit, i, j + 1);
        }
        // ì•„ë˜ìª½ ì²´í¬
        if (i + 1 < picture.length && picture[i][j] == picture[i + 1][j]) {
            ret += dfs(picture, visit, i + 1, j);
        }

        return ret;
    }

    public int[] solution(int m, int n, int[][] picture) {
        int numberOfArea = 0;
        int maxSizeOfOneArea = 0;
        int[][] visit = new int[100][100];

        for (int i = 0; i < picture.length; i++) {
            for (int j = 0; j < picture[0].length; j++) {
                if (visit[i][j] == 0 && picture[i][j] != 0) {
                    numberOfArea++;
                    maxSizeOfOneArea = max(maxSizeOfOneArea, dfs(picture, visit, i, j));
                }
            }
        }

        int[] answer = new int[2];
        answer[0] = numberOfArea;
        answer[1] = maxSizeOfOneArea;
        return answer;
    }
}

```

</details><br/>

# ìŠ¤í”„ë§ë¶€íŠ¸

ê¹€ì˜í•œë‹˜ ì¸í”„ëŸ° ê°•ì˜(ìŠ¤í”„ë§ ì…ë¬¸) ìˆ˜ê°•í•˜ë©´ì„œ ê³µë¶€í•œ ë‚´ìš© ì •ë¦¬

## Intellij ë‹¨ì¶•í‚¤

Show Context Actions : `Alt+Enter`

> implement methods, import ë“± ë‹¤ì–‘í•˜ê²Œ í™œìš©ëœë‹¤.

Go to Declaration or Usages : `Ctrl+Click`Â or `Ctrl+B`

> í´ë˜ìŠ¤ë¥¼Â í´ë¦­í•˜ë©´ í•´ë‹¹ í´ë˜ìŠ¤ì˜ ì •ì˜ë¡œ ì´ë™í•œë‹¤.

## ë™ì‹œì„±Â ë¬¸ì œ

ê³µìœ ë˜ëŠ” ë³€ìˆ˜ì˜ ê²½ìš° ë™ì‹œì„±ë¬¸ì œê°€ ìˆì„ ìˆ˜ ìˆë‹¤. ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ì„œ ì‹¤ë¬´ì—ì„œëŠ” AtomicLong ë“±ì„ ì‚¬ìš©í•œë‹¤.

## Optional

nullë¡œ ë°˜í™˜ë  ê°€ëŠ¥ì„±ì´ ìˆëŠ” ê°ì²´ì˜ ê²½ìš° Optionalë¡œ ê´€ë¦¬í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.

### `Optional.ofNullable()`

ì´ ë©”ì„œë“œ ì•ˆì— ê°ì²´ë¥¼ ë„£ìœ¼ë©´ `Optional<í´ë˜ìŠ¤ëª…>` íƒ€ì…ì˜ ê°ì²´ë¡œ ë°˜í™˜ëœë‹¤.

# ğŸ“• ìë°”ì˜ ì •ì„

## ëŒë‹¤ì‹

í´ë˜ìŠ¤ì˜ ë©”ì„œë“œì™€ ë‹¬ë¦¬ ë…ë¦½ì ìœ¼ë¡œ ì‚¬ìš© ê°€ëŠ¥í•œ í•¨ìˆ˜

> ì‹¤ì œë¡œëŠ” ìµëª… í´ë˜ìŠ¤ì˜ ê°ì²´ì™€ ë™ì¼í•˜ì§€ë§Œ ëŒë‹¤ì‹ì„ ì‚¬ìš©í•¨ìœ¼ë¡œì¨ ì½”ë“œê°€ ë” ê°„ê²°í•˜ê³  ì´í•´í•˜ê¸° ì‰¬ì›Œì¡Œë‹¤.

`(ë§¤ê°œë³€ìˆ˜ ì„ ì–¸ë¶€) -> { í•¨ìˆ˜body }` í˜•íƒœë¡œ êµ¬ì„±ëœë‹¤.

ì˜ˆì‹œ : `(int a) -> { return a+3 }`

### íŠ¹ì§•

* ì´ë•Œ ëŒ€ë¶€ë¶„ì˜Â ê²½ìš° ìë£Œí˜•ì€ ì¶”ë¡ ì´ ê°€ëŠ¥í•˜ê¸° ë•Œë¬¸ì— ìƒëµì´ ê°€ëŠ¥í•˜ë‹¤. 

* ë§¤ê°œë³€ìˆ˜ê°€ í•˜ë‚˜ë§Œ ìˆê³  ìë£Œí˜•ì€ ìƒëµí•  ìˆ˜ ìˆëŠ” ê²½ìš° ê´„í˜¸ë¥¼ ìƒëµí•  ìˆ˜ ìˆë‹¤. `a -> { return a+3; }`
* í•¨ìˆ˜Â body ë¶€ë¶„ì— ë¬¸ì¥ì´ í•˜ë‚˜ì¸ ê²½ìš° ê´„í˜¸ì™€ return ;ë¥¼ ìƒëµí•˜ê³  ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. `aÂ ->Â a+3`

### í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤

ëŒë‹¤ì‹ì„ ë‹¤ë£¨ê¸° ìœ„í•œ ì¸í„°í˜ì´ìŠ¤

ì¶”ìƒ ë©”ì„œë“œëŠ” ì˜¤ì§ í•˜ë‚˜ë§Œ ì¡´ì¬í•  ìˆ˜ ìˆë‹¤.<br/>(ëŒë‹¤ì‹ê³¼ 1ëŒ€1ë¡œ ë§¤ì¹­ë˜ê¸° ìœ„í•´ì„œ)

í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©í•¨ìœ¼ë¡œì¨ ëŒë‹¤ì‹ì„ ë§¤ê°œë³€ìˆ˜ë¡œ ì „ë‹¬ë°›ê±°ë‚˜ ëŒë‹¤ì‹ì„ ë°˜í™˜í•˜ëŠ” ê²ƒì´ ê°€ëŠ¥í•´ì§„ë‹¤.

```java
@FunctionalInterface
interface MyFunction {
    public abstract int sum(int a, int b);
}

public class LambdaEx {
    static void action(MyFunction f) {
        System.out.println(f.sum(1, 3));
    }

    public static void main(String[] args) {
        action((a, b) -> a + b + 3);
    }
}
```

ëŒ€ë¶€ë¶„ì˜ ë©”ì„œë“œëŠ” í˜•íƒœê°€ ë¹„ìŠ·í•˜ê¸° ë•Œë¬¸ì— **java.util.function** íŒ¨í‚¤ì§€ì— ì •ì˜ë˜ì–´ ìˆëŠ” í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ë“¤ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¬ì‚¬ìš©ì„±ì´ë‚˜ ìœ ì§€ë³´ìˆ˜ ì¸¡ë©´ì—ì„œ ì¢‹ë‹¤.

ì˜ˆì‹œë¡œ `Stream`Â interfaceì˜ `filter` ë©”ì„œë“œëŠ” java.util.function.Predicateë¥¼ ì‚¬ìš©í•œë‹¤.

```java
Stream<T> filter(Predicate<? super T> predicate);
```

### method reference

í´ë˜ìŠ¤ì˜ ë©”ì„œë“œë¥¼ ëŒë‹¤ì‹ìœ¼ë¡œ ì‚¬ìš©í• ë•Œ `í´ë˜ìŠ¤ëª…::ë©”ì„œë“œ` í˜•íƒœë¡œ ë” ê°„í¸í•˜ê²Œ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆë‹¤.

> ì½”ë“œë¥¼ ê°„ëµí™”í• ë•Œ ìœ ìš©í•´ì„œ ë§ì´ ì‚¬ìš©í•œë‹¤.

* static ë©”ì„œë“œ (í´ë˜ìŠ¤ ë©”ì„œë“œ)

  ```java
  // a -> System.out.println(a)
  System.out::println
  ```

* ì¸ìŠ¤í„´ìŠ¤ ë©”ì„œë“œ

  > ì¸ìŠ¤í„´ìŠ¤ ë©”ì„œë“œëŠ” staticì´ ë¶™ì§€ ì•ŠëŠ” ë©”ì„œë“œ,<br/>ì¦‰ ê°ì²´ê°€ ìˆì–´ì•¼ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ë©”ì„œë“œì´ë‹¤.

  ```java
  // (String s1, String s2) -> s1.equals(s2)
  String::equals
  ```

* ìƒì„±ì `í´ë˜ìŠ¤ëª…::new`

* íŠ¹ì • ê°ì²´ì˜ ë©”ì„œë“œ `ê°ì²´ëª…::ë©”ì„œë“œ`

## ìŠ¤íŠ¸ë¦¼

ìë£Œí˜•ì— ìƒê´€ì—†ì´ ë™ì¼í•œ ì ‘ê·¼ ë°©ì‹ì„ ì‚¬ìš©í•¨ìœ¼ë¡œì¨ ì½”ë“œë¥¼ ê°„ê²°í•˜ê³  ì´í•´í•˜ê¸° ì‰½ê³  ì¬ì‚¬ìš©ì„±ì´ ë†’ë„ë¡ ë§Œë“¤ì—ˆë‹¤.

* Read Only

* ì¼íšŒìš©

* ë‚´ë¶€ ë°˜ë³µ (ë§¤ê°œë³€ìˆ˜ë¡œ ëŒë‹¤ì‹ì„ ë°›ê³  ë°˜ë³µì€ ë‚´ë¶€ì—ì„œ ì²˜ë¦¬í•¨ìœ¼ë¡œì¨ ì½”ë“œë¥¼ ê°„ê²°í•˜ê²Œ ë§Œë“ ë‹¤.)

* ìµœì¢… ì—°ì‚°ì´ ìˆ˜í–‰ë˜ê¸° ì „ê¹Œì§€ëŠ” ì¤‘ê°„ ì—°ì‚°ì´ ìˆ˜í–‰ë˜ì§€ ì•ŠëŠ”ë‹¤.

  > ì¤‘ê°„ì—°ì‚°ì„ ì°¨ë¡€ë¡œ ìˆ˜í–‰í•˜ê³  ë§ˆì§€ë§‰ì— ìµœì¢…ì—°ì‚°ì´ ìˆ˜í–‰ë˜ëŠ”ì¤„ ì•Œì•˜ëŠ”ë° ê° ìš”ì†Œë³„ë¡œ ì¤‘ê°„ì—°ì‚°ì„ ê±°ì¹˜ê³  ìµœì¢…ì—°ì‚°ì´ ìˆ˜í–‰ë˜ëŠ” ê³¼ì •ì´ ë°˜ë³µë˜ëŠ” ëŠë‚Œì¸ê²ƒê°™ë‹¤.

### ìŠ¤íŠ¸ë¦¼Â ìƒì„±

* **ì»¬ë ‰ì…˜**<br/>ìµœê³  ì¡°ìƒì— `stream()` ë©”ì†Œë“œê°€ ì •ì˜ë˜ì–´ ìˆë‹¤.
* **ë°°ì—´**<br/>Streamê³¼ Arraysì— static ë©”ì†Œë“œê°€ ì •ì˜ë˜ì–´ ìˆë‹¤.<br/>`Stream<T> Stream.of(T... values)`<br/>`Stream<T> Stream.of(T[])`<br/>`Stream<T> Arrays.stream(T[])`<br/>`Stream<T> Arrays.stream(T[] array, int startInclusive, int endExclusive)`<br/>
* **íŠ¹ì • ë²”ìœ„ì˜ ì •ìˆ˜**<br/>`IntStream.range(int begin, int end)`<br/>`IntStream.rangeClosed(int begin, int end)`<br/>LongStreamì—ë„ ë™ì¼í•œ ë©”ì„œë“œê°€ ì •ì˜ë˜ì–´ ìˆë‹¤.
* **ì„ì˜ì˜ ìˆ˜**<br/>Randomí´ë˜ìŠ¤ì—ì„œ ë‹¤ìŒê³¼ ê°™ì€ ë©”ì„œë“œê°€ ì •ì˜ë˜ì–´ ìˆë‹¤.<br/>`IntStream Random.ints()` - ë¬´í•œ ìŠ¤íŠ¸ë¦¼. `limit()` ì¤‘ê°„ ì—°ì‚°ê³¼ í•¨ê»˜ ì‚¬ìš©í•´ì•¼ í•œë‹¤.<br/>`IntStream Random.ints(long streamSize)`<br/>`IntStream Random.ints(int begin, int end)`<br/>`IntStream Random.ints(long streamSize, int begin, int end)`<br/>LongStream, DoubleStream íƒ€ì…ë„ ì œê³µëœë‹¤.

### ì—°ì‚°

<details><summary>ì¤‘ê°„ ì—°ì‚° (Stream ë°˜í™˜)</summary>

* `Stream<T> distinct()`
* **`Stream<T> filter(Predicate<T> predicate)`**
* `Stream<T> limit(long maxSize)` 
* `Stream<T> skip(long n)`
* `Stream<T> peek(Consumer<T> action)`
* **`Stream<T> sorted()`<br/>`Stream<T> sorted(Comparator<T> comparator)`**
* **`Stream<R> map(Function<T, R> mapper)`**, <br/>`DoubleStream mapToDouble(ToDoubleFunction<T> mapper)` ...<br/>`Stream<R> flatMap(Function<T,Stream<R>> mapper)`, ....

</details>

<details><summary>ìµœì¢… ì—°ì‚° (ìµœì¢… ì—°ì‚°ì„ ìˆ˜í–‰í•œ ë’¤ í•´ë‹¹ Streamì€ ë‹«íŒë‹¤.)</summary>

* `void forEach(Consumer<? super T> action)`<br/>`void forEachOrdered(Consumer<? super T> action)`
* `long count()`
* `Optional<T> max (Comparator<? super T> comparator)`<br/>`Optional<T> min (Comparator<? super T> comparator)`
* `Optional<T> findAny()`<br/>`Optional<T> findFirst()`
* `boolean allMatch(Predicate<T> p)`<br/>`boolean anyMatch(Predicate<T> p)`<br/>`boolean noneMatch(Predicate<T> p)`
* `Object[] toArray()`<br/>`A[] toArray(IntFunction<A[]>)`
* `Optional<T> reduce(BinaryOperator<T> accumulator)`<br/>`T reduce(T identity, BinaryOperator<T> accumulator)`<br/>`U reduce(U identity, BiFunction<U,T,U> accumulator, BinaryOperator<U> combiner)`
* `R collect(Collector<T,A,R> collector)`<br/>`R collect(Supplier<R> supplier, BiConsumer<R, T> accumulator, BiConsumer<R,R> combiner)`

</details>

### Comparator ë©”ì„œë“œ

* `naturalOrder()`<br/>`reverseOrder()`
* `comparing(Function<T, U> keyExtractor)`<br/>`comparing(Function<T, U> keyExtractor, Comparator<U> keyComparator)`
* `thenComparing(Comparator<T> other)`<br/>`thenComparing(Function<T, U> keyExtractor)`<br/>`thenComparing(Function<T, U> keyExtractor, Comparator<U> keyComp)`<br/>

ì˜ˆì‹œ

```java
class Human {
    private int age;
    private String name;

    public Human(int age, String name) {
        this.age = age;
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return age + " " + name;
    }
}

public class Solution {
    public static void main(String[] args) {
        List<Human> L = new ArrayList<>();
        L.add(new Human(20, "a"));
        L.add(new Human(10, "ab"));
        L.add(new Human(30, "abc"));
        L.add(new Human(20, "c"));
        L.add(new Human(10, "cd"));
        L.add(new Human(30, "cde"));
        L.add(new Human(20, "b"));
        L.add(new Human(10, "bc"));
        L.add(new Human(30, "bcd"));
        // ë‚˜ì´ ê¸°ì¤€ìœ¼ë¡œ ë‚´ë¦¼ì°¨ìˆœ, ì´ë¦„ ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
        L.stream().sorted(Comparator.comparing(Human::getAge)
                .thenComparing(Human::getName))
                .forEach(System.out::println);
    }
}
```

